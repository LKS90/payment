<?php

/**
 * @file
 * Tests for payment.module.
 */

/**
 * Tests action hook and callback invocations.
 */
class PaymentActionHookAndCallbackTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Action hook and callback invocations',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment_test', 'paymentmethodbasic');
  }

  /**
   * Test whether hook_payment_validate() is invoked.
   */
  function testActionHooksAndCallbacks() {
    $payment_method = new PaymentMethod(array(
      'controller' => payment_method_controller_load('PaymentMethodBasicController'),
    ));
    $payment = new Payment(array(
      'method' => $payment_method,
      'finish_callback' => 'payment_test_finish_callback',
    ));
    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'payment_test',
      'amount' => 1,
    )));
    $validation = FALSE;
    try {
      $payment->payment_test_payment_validate = TRUE;
      $payment_method->validate($payment);
    }
    catch (PaymentValidationException $e) {
      $validation = $e->getMessage() == 'payment_test';
    }
    unset($payment->payment_test_payment_validate);
    $this->assertTrue($validation, 'hook_payment_validate() is invoked when validating a payment before execution.');
    $payment->execute();
    $this->assertTrue(isset($payment->payment_test_payment_pre_execute), 'hook_payment_pre_execute() is invoked before executing a payment.');
    $this->assertTrue(isset($payment->payment_test_payment_status_change), 'hook_payment_status_change() is invoked before executing a payment.');
    $this->assertTrue(isset($payment->payment_test_finish_callback), 'The finish callback is invoked after executing a payment.');
  }
}

/**
 * Tests info hook return values.
 */
class PaymentInfoHookTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Info hook data',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp($this->modules());
  }

  /**
   * Return modules whose hook implementations should be tested.
   *
   * @return array
   */
  function modules() {
    return array('payment');
  }

  /**
   * Test hook_payment_method_controller_info().
   */
  function HookPaymentMethodControllerInfo() {
    foreach ($this->modules() as $module) {
      if (module_hook($module, 'payment_method_controller_info')) {
        $controller_info = module_invoke($module, 'payment_method_controller_info');
        if (is_array($controller_info)) {
          $valid = TRUE;
          foreach ($controller_info as $controller_name) {
            if (!is_string($controller_name)) {
              $valid = FALSE;
              break;
            }
          }
        }
        else {
          $valid = FALSE;
        }
        $this->assertTrue($valid, $module . '_payment_method_controller_info() returns an array of strings.');
      }
    }
  }

  /**
   * Test a hook that returns an array of objects.
   */
  function hookThatReturnsObjects($hook, $class_name) {
    $module_info = system_get_info('module');
    foreach ($this->modules() as $module) {
      if (module_hook($module, $hook)) {
        $infos = module_invoke($module, $hook);
        if (is_array($infos)) {
          foreach ($infos as $info) {
            $valid = TRUE;
            if (!is_a($info, $class_name)) {
              $valid = FALSE;
              break;
            }
          }
        }
        else {
          $valid = FALSE;
        }
        $this->assertTrue($valid, $module . '_' . $hook . '() returns an array of ' . $class_name . ' objects.');
      }
    }
  }

  function testInfoHookReturnValues() {
    $this->hookThatReturnsObjects('payment_status_info', 'PaymentStatusInfo');
    $this->hookThatReturnsObjects('payment_line_item_info', 'PaymentLineItemInfo');
    $this->HookPaymentMethodControllerInfo();
  }
}

/**
 * Test line item handling.
 */
class PaymentLineItemTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment line item handling',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment_test');
  }

  /**
   * Test line item handling.
   */
  function testPaymentLineItemHandling() {
    $payment = new Payment;
    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'foo',
      'amount' => 19.11,
      'tax_rate' => 0.1,
    )));

    // Test Payment::setLineItem();
    $this->assertTrue($payment->line_items['foo']->name == 'foo', 'Payment::setLineItem() adds a PaymentLineItem object to Payment::line_items.');

    // Test Payment::unitAmount() without tax.
    $this->assertTrue($payment->line_items['foo']->unitAmount(FALSE) == 19.11, 'Payment::unitAmount() returns amount excluding tax.');

    // Test Payment::unitAmount() with tax.
    $this->assertTrue($payment->line_items['foo']->unitAmount(TRUE) == 21.021, 'Payment::unitAmount() returns amount including tax.');

    // Test Payment::totalAmount() without tax.
    $this->assertTrue($payment->totalAmount(FALSE) == 19.11, 'Payment::totalAmount() returns amount excluding tax.');

    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'bar',
      'amount' => 19.78,
    )));

    // Test Payment::totalAmount() without passed on amounts.
    $this->assertTrue($payment->totalAmount(TRUE) == 40.801, 'Payment::totalAmount() adds up Payment::line_items.');

    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'beer',
      'amount' => 47.11,
    )));

    // Test Payment::totalAmount() with passed on amounts.
    $line_items = $payment->getLineItems('payment_test');
    $this->assertTrue($payment->totalAmount(TRUE, $line_items) == 40.801, 'Payment::totalAmount() adds up only passed on line items.');

    // Test payment_line_item_get_specific() and whether
    // Payment::getLineItems() can get line items that are not exposed
    // through hook_payment_line_item_info().
    $line_items = $payment->getLineItems('beer');
    $this->assertTrue($payment->totalAmount(TRUE, $line_items) == 47.11, 'payment_line_item_get_specific() only returns the requested line item.');

    // Test payment_line_item_get_all().
    $line_items = $payment->getLineItems('payment_all');
    $this->assertTrue(count($line_items) == 3, 'payment_line_item_get_all() returns all line items.');
  }
}

/**
 * Test payment status item handling.
 */
class PaymentStatusItemTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment status item handling',
      'group' => 'Payment',
    );
  }

  /**
   * Implements DrupalWebTestCase::setUp().
   */
  function setUp() {
    parent::setUp('payment');
  }

  /**
   * Test payment status item handling.
   */
  function testPaymentStatusItem() {
    $payment = new Payment;
    $status_pending = new PaymentStatusItem(PAYMENT_STATUS_PENDING);
    $status_success = new PaymentStatusItem(PAYMENT_STATUS_SUCCESS);
    $payment->setStatus($status_pending);
    $payment->setStatus($status_success);
    $this->assertTrue($payment->getStatus() === $status_success, 'Payment::setStatus() sets status items in the right order and Payment::getStatus() retrieves them.');
  }
}

/**
 * Test payment validation.
 */
class PaymentValidationTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment validation',
      'group' => 'Payment',
    );
  }

  /**
   * Implements DrupalWebTestCase::setUp().
   */
  function setUp() {
    parent::setUp('payment', 'paymentmethodbasic', 'payment_test');

    // Set up a valid payment.
    $this->payment_method = new PaymentMethod(array(
      'controller' => payment_method_controller_load('PaymentMethodBasicController'),
    ));
    $this->payment_method->controller->currencies = array(
      'XXX' => array(
        'minimum' => 10,
        'maximum' => 20,
      ),
    );
    $this->payment = new Payment(array(
      'currency_code' => 'XXX',
      'finish_callback' => 'payment_test_finish_callback',
      'method' => $this->payment_method,
    ));
    $this->payment->setLineItem(new PaymentLineItem(array(
      'name' => 'payment_test',
      'amount' => 15,
    )));
  }

  /**
   * Test payment validation.
   */
  function testPaymentValidation() {
    // Test that a valid payment validates.
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationException $e) {
      $valid = FALSE;
    }
    $this->assertTrue($valid, 'PaymentMethodController::validate() does not invalidate a valid payment.');

    // Test that a payment without a currency code set invalidates.
    $currency = $this->payment->currency_code;
    $this->payment->currency_code = '';
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationMissingCurrencyException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, 'PaymentMethodController::validate() invalidates a payment that has no currency set.');
    $this->payment->currency_code = $currency;

    // Test that a payment with a total amount below PAYMENT_MINIMUM_AMOUNT
    // invalidates.
    $currencies = $this->payment_method->controller->currencies;
    $this->payment_method->currencies = array();
    $line_items = $this->payment->line_items;
    $this->payment->line_items = array();
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountBelowMinimumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, 'PaymentMethodController::validate() invalidates a payment of which the amount is below the default minimum of ' . PAYMENT_MINIMUM_AMOUNT . '.');
    $this->payment_method->currencies = $currencies;
    $this->payment->line_items = $line_items;

    // Test that a payment with a total amount below its controller's minimum
    // invalidates.
    $line_items = $this->payment->line_items;
    $this->payment->line_items = array();
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountBelowMinimumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, "PaymentMethodController::validate() invalidates a payment of which the amount is below its controller's supported minimum.");
    $this->payment->line_items = $line_items;

    // Test that a payment with a total amount above its controller's maximum
    // invalidates.
    $this->payment->setLineItem(new PaymentLineItem(array(
      'name' => 'payment_test2',
      'amount' => 25,
    )));
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountExceedsMaximumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, "PaymentMethodController::validate() invalidates a payment of which the amount exceeds its controller's supported maximum.");
    unset($this->payment->line_items['payment_test2']);
  }
}

/**
 * Tests the payment_line_item form element.
 */
class PaymentLineItemFormElementTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment line item form element',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'payment_test');
    $this->PaymentLineItemData = array(
      'line_item[container_0][amount]' => '10.0',
      'line_item[container_0][description]' => 'foo',
      'line_item[container_0][name]' => 'bar',
      'line_item[container_0][quantity]' => '1',
      'line_item[container_0][tax_rate]' => '10',
    );
  }

  /**
   * Test the presence of widget's input elements.
   */
  function LineItemElements($delta_max = 0) {
    for ($delta = 0; $delta <= $delta_max; $delta++) {
      foreach (array('amount', 'description', 'name', 'quantity', 'tax-rate') as $name) {
        $elements = $this->xpath('//input[@id="edit-line-item-container-' . $delta . '-' . $name . '"]');
        $this->assertTrue(isset($elements[0]), "Payment line item configuration widget contains <em>$name</em> element for line item $delta.");
      }
    }
  }

  /**
   * Test the presence of widget's submit button.
   */
  function SubmitButton($present) {
    $elements = $this->xpath('//input[@id="payment-ajax-replace"]');
    if ($present) {
      $this->assertTrue(isset($elements[0]), "Payment line item configuration widget contains an <em>Add a line item</em> button if the number if line items is less than the widget's cardinality.");
    }
    else {
      $this->assertFalse(isset($elements[0]), 'Payment line item configuration widget contains no <em>Add a line item</em> button.');
    }
  }

  /**
   * Test a regular submission.
   */
  function testSubmission() {
    $this->drupalGet('payment-test-form-element-payment-line-item');
    $this->LineItemElements();
    $this->SubmitButton(TRUE);
    $this->drupalPost(NULL, array(), t('Add a line item'));
    $this->LineItemElements(1);
    $this->SubmitButton(FALSE);
  }

  /**
   * Test an AJAX submission.
   */
  function testAJAXSubmission() {
    $this->drupalPostAJAX('payment-test-form-element-payment-line-item', array(), 'payment-line-item', NULL, array(), array(), 'payment-test-form-payment-line-item');
    $this->LineItemElements(1);
    $this->SubmitButton(FALSE);
  }

  /**
   * Test default value handling.
   */
  function testDefaultValues() {
    $this->drupalGet('payment-test-form-element-payment-line-item/default-values');
    foreach (payment_test_default_line_items() as $delta => $line_item) {
      $properties = array(
        'amount' => $line_item->amount,
        'description' => $line_item->description,
        'name' => $line_item->name,
        'quantity' => $line_item->quantity,
        'tax_rate' => $line_item->tax_rate * 100,
      );
      foreach ($properties as $property => $value) {
        $elements = $this->xpath('//input[@id="edit-line-item-container-' . $delta . '-' . drupal_clean_css_identifier($property) . '" and @value="' . $value . '"]');
        $this->assertTrue(isset($elements[0]), "The element contains the <em>$property</em> value for default line item $delta.");
      }
    }
  }

  /**
   * Test validation.
   */
  function testValidation() {
    // Test valid values.
    $this->drupalPost('payment-test-form-element-payment-line-item', $this->PaymentLineItemData, t('Submit'));
    $this->assertUrl('user', array(), 'Valid values trigger form submission.');

    // Test leaving some elements empty.
    $values = array(
      'line_item[container_0][description]' => '',
    ) + $this->PaymentLineItemData;
    $this->drupalPost('payment-test-form-element-payment-line-item', $values, t('Submit'));
    $this->assertRaw(t('%title is required, or leave all fields for this line item empty.', array(
      '%title' => t('Description'),
    )), "Partially filling in a line item's element throws a validation error.");

    // Test a non-integer quantity.
    $values =  array(
      'line_item[container_0][quantity]' => $this->randomName(2),
    );
    $this->drupalPost('payment-test-form-element-payment-line-item', $values, t('Submit'));
    $this->assertText(t('Quantity should be a positive integer.'), 'A non-integer amount throws a validation error.');

    // Test a non-integer tax rate.
    $values =  array(
      'line_item[container_0][tax_rate]' => $this->randomName(2),
    );
    $this->drupalPost('payment-test-form-element-payment-line-item', $values, t('Submit'));
    $this->assertText(t('Tax rate should be a positive integer.'), 'A non-integer tax rate throws a validation error.');
  }
}

/**
 * Tests the payment_line_item form element.
 */
class PaymentAmountFormElementTest extends DrupalWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment amount form element',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'payment_test');
  }

  /**
   * Test validation.
   */
  function testValidation() {
    // Test valid values.
    $values =  array(
      'amount' => '49.95',
    );
    $this->drupalPost('payment-test-form-element-payment-amount', $values, t('Submit'));
    $this->assertUrl('user', array(), 'A valid value higher than the default <em>#minimum_value</em> triggers form submission.');
    $values =  array(
      'amount' => '50,95',
    );
    $this->drupalPost('payment-test-form-element-payment-amount/50', $values, t('Submit'));
    $this->assertUrl('user', array(), 'A valid value higher than an explicitely configured <em>#minimum_value</em> triggers form submission.');

    // Test illegal characters.
    $values =  array(
      'amount' => $this->randomName(2),
    );
    $this->drupalPost('payment-test-form-element-payment-amount', $values, t('Submit'));
    $this->assertText(t('The amount can only consist of decimals and one decimal mark.'), 'Non-alphanumeric characters that are neither a period nor a comma throw a validation error.');

    // Test multiple decimal marks.
    $values =  array(
      'amount' => '49,.95',
    );
    $this->drupalPost('payment-test-form-element-payment-amount', $values, t('Submit'));
    $this->assertText(t('The amount can only have one decimal mark.'), 'Multiple decimal marks throw a validation error.');

    // Test the minimum value.
    $values =  array(
      'amount' => '49.95',
    );
    $this->drupalPost('payment-test-form-element-payment-amount/50', $values, t('Submit'));
    $this->assertText(t('The minimum amount is !amount.', array(
      '!amount' => payment_amount_human_readable(50, 'XXX'),
    )), 'An amount below the minimum throws a validation error.');
  }
}