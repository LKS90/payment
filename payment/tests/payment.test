<?php

/**
 * @file
 * Tests for payment.module.
 */

class PaymentWebTestCase extends DrupalWebTestCase {

  /**
   * Create, save, and return a Payment.
   *
   * @param PaymentMethod $payment_method
   *   An optional payment method to set. Defaults to PaymentMethodUnavailable.
   *
   * @return Payment
   */
  function paymentCreate(PaymentMethod $payment_method = NULL) {
    $payment_method = $payment_method ? $payment_method : new PaymentMethodUnavailable;
    $payment = new Payment(array(
      'currency_code' => 'XXX',
      'finish_callback' => 'paymenttest_finish_callback',
      'method' => $payment_method,
    ));
    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'foo',
      'amount' => 1.0,
      'tax_rate' => 0.1,
    )));
    entity_save('payment', $payment);

    return $payment;
  }

  /**
   * Create, save, and return a PaymentMethod.
   *
   * @param PaymentMethodController $controller
   *   An optional controller to set. Defaults to
   *   PaymentMethodControllerUnavailable.
   *
   * @return PaymentMethod
   */
  function paymentMethodCreate(PaymentMethodController $controller = NULL) {
    $name = $this->randomName();
    $controller = $controller ? $controller : payment_method_controller_load('PaymentMethodControllerUnavailable');
    $payment_method = new PaymentMethod(array(
      'controller' => $controller,
      'controller_data' => $controller->controller_data_defaults,
      'name' => $name,
      'title' => $name,
    ));
    entity_save('payment_method', $payment_method);

    return $payment_method;
  }

  /**
   * Return permissions' human-readable titles and their machine names.
   *
   * @param array $permissions
   *   The permissions' machine names.
   *
   * @return string
   */
  function paymentPermissionLabel(array $permissions) {
    static $info = NULL;

    if (is_null($info)) {
      $info = payment_permission();
    }

    $labels = array();
    foreach ($permissions as $permission) {
      $labels[] = '<em>' . $info[$permission]['title'] . ' (' . $permission . ')</em>';
    }

    return implode(', ', $labels);
  }

  /**
   * Test a URL path's permissions.
   *
   * @param string $path
   * @param string $permission
   * @param string $comment
   *
   * @return NULL
   */
  function paymentCheckPathPermission($path, $permission, $comment = NULL) {
    if ($comment) {
      $comment = " ($comment)";
    }
    $permission_text = $this->paymentPermissionLabel(array($permission));
    $this->drupalLogout();
    $this->drupalGet($path);
    $this->assertText(t('Access denied'), "Anonymous users cannot view admin/config/services/payment/method$comment");
    $this->drupalLogin($this->drupalCreateUser());
    $this->drupalGet($path);
    $this->assertText(t('Access denied'), "Authenticated users cannot view admin/config/services/payment/method$comment without permission $permission_text");
    $this->drupalLogin($this->drupalCreateUser(array($permission)));
    $this->drupalGet($path);
    $this->assertNoText(t('Access denied'), "Authenticated users can view admin/config/services/payment/method$comment with permission $permission_text");
  }

  /**
   * Test an entity's permissions.
   *
   * @param mixed $entity
   * @param string $entity_type
   *   The value suffixed with "_access" will be used as the access callback,
   *   which receives the $operation, $entity and a user account object as
   *   parameters.
   * @param array $permissions
   * @param string $operation
   *
   * @return NULL
   */
  function paymentCheckEntityPermission($entity, $entity_type, array $permissions, $operation) {
    $user_access_permissions = &drupal_static('user_access');
    $account_1 = drupal_anonymous_user();
    $account_1->uid = 1;
    $account_2 = drupal_anonymous_user();
    $account_2->uid = 2;
    $function = $entity_type . '_access';
    $uid_string = $entity->uid ? ' with UID ' . $entity->uid : NULL;

    $this->assertTrue($function($operation, $entity, $account_1), "UID 1 can $operation a $entity_type$uid_string without permission(s) " . $this->paymentPermissionLabel($permissions));
    foreach ($permissions as $i => $permission) {
      $assertion_permissions = $permissions;
      unset($assertion_permissions[$i]);
      $user_access_permissions[2] = array_fill_keys($assertion_permissions, TRUE);
      $this->assertFalse($function($operation, $entity, $account_2), "UID 2 cannot $operation a $entity_type$uid_string without permission " . $this->paymentPermissionLabel(array($permissions[$i])));
    }
    $user_access_permissions[2] = array_fill_keys($permissions, TRUE);
    $this->assertTrue($function($operation, $entity, $account_1), "UID 2 can $operation a $entity_type$uid_string with permission(s) " . $this->paymentPermissionLabel($permissions));
  }
}

/**
 * Tests action hook and callback invocations.
 */
class PaymentActionHookAndCallbackTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Action hook and callback invocations',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('paymenttest', 'paymentmethodbasic');
  }

  /**
   * Test whether hook_payment_validate() is invoked.
   */
  function testActionHooksAndCallbacks() {
    $payment_method = new PaymentMethod(array(
      'controller' => payment_method_controller_load('PaymentMethodBasicController'),
      'controller_data' => array(
        'status' => PAYMENT_STATUS_SUCCESS,
      ),
    ));
    $payment = new Payment(array(
      'method' => $payment_method,
      'finish_callback' => 'paymenttest_finish_callback',
    ));
    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'paymenttest',
      'amount' => 1,
    )));
    $validation = FALSE;
    try {
      $payment->paymenttest_payment_validate = TRUE;
      $payment_method->validate($payment);
    }
    catch (PaymentValidationException $e) {
      $validation = $e->getMessage() == 'paymenttest';
    }
    unset($payment->paymenttest_payment_validate);
    $this->assertTrue($validation, 'hook_payment_validate() is invoked when validating a payment before execution.');
    $payment->execute();
    $this->assertTrue(isset($payment->paymenttest_payment_pre_execute), 'hook_payment_pre_execute() is invoked before executing a payment.');
    $this->assertTrue(isset($payment->paymenttest_payment_status_change), 'hook_payment_status_change() is invoked before executing a payment.');
    $this->assertTrue(isset($payment->paymenttest_finish_callback), 'The finish callback is invoked after executing a payment.');
  }
}

/**
 * Tests info hook return values.
 */
class PaymentInfoHookTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Info hook data',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp($this->modules());
  }

  /**
   * Return modules whose hook implementations should be tested.
   *
   * @return array
   */
  function modules() {
    return array('payment');
  }

  /**
   * Test hook_payment_method_controller_info().
   */
  function HookPaymentMethodControllerInfo() {
    foreach ($this->modules() as $module) {
      if (module_hook($module, 'payment_method_controller_info')) {
        $controller_info = module_invoke($module, 'payment_method_controller_info');
        if (is_array($controller_info)) {
          $valid = TRUE;
          foreach ($controller_info as $controller_name) {
            if (!is_string($controller_name)) {
              $valid = FALSE;
              break;
            }
          }
        }
        else {
          $valid = FALSE;
        }
        $this->assertTrue($valid, $module . '_payment_method_controller_info() returns an array of strings.');
      }
    }
  }

  /**
   * Test a hook that returns an array of objects.
   */
  function hookThatReturnsObjects($hook, $class_name) {
    $module_info = system_get_info('module');
    foreach ($this->modules() as $module) {
      if (module_hook($module, $hook)) {
        $infos = module_invoke($module, $hook);
        if (is_array($infos)) {
          foreach ($infos as $info) {
            $valid = TRUE;
            if (!is_a($info, $class_name)) {
              $valid = FALSE;
              break;
            }
          }
        }
        else {
          $valid = FALSE;
        }
        $this->assertTrue($valid, $module . '_' . $hook . '() returns an array of ' . $class_name . ' objects.');
      }
    }
  }

  function testInfoHookReturnValues() {
    $this->hookThatReturnsObjects('payment_status_info', 'PaymentStatusInfo');
    $this->hookThatReturnsObjects('payment_line_item_info', 'PaymentLineItemInfo');
    $this->HookPaymentMethodControllerInfo();
  }
}

/**
 * Test line item handling.
 */
class PaymentLineItemTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment line item handling',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('paymenttest');
  }

  /**
   * Test line item handling.
   */
  function testPaymentLineItemHandling() {
    $payment = new Payment;
    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'foo',
      'amount' => 19.11,
      'tax_rate' => 0.1,
    )));

    // Test Payment::setLineItem();
    $this->assertTrue($payment->line_items['foo']->name == 'foo', 'Payment::setLineItem() adds a PaymentLineItem object to Payment::line_items.');

    // Test Payment::unitAmount() without tax.
    $this->assertTrue($payment->line_items['foo']->unitAmount(FALSE) == 19.11, 'Payment::unitAmount() returns amount excluding tax.');

    // Test Payment::unitAmount() with tax.
    $this->assertTrue($payment->line_items['foo']->unitAmount(TRUE) == 21.021, 'Payment::unitAmount() returns amount including tax.');

    // Test Payment::totalAmount() without tax.
    $this->assertTrue($payment->totalAmount(FALSE) == 19.11, 'Payment::totalAmount() returns amount excluding tax.');

    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'bar',
      'amount' => 19.78,
    )));

    // Test Payment::totalAmount() without passed on amounts.
    $this->assertTrue($payment->totalAmount(TRUE) == 40.801, 'Payment::totalAmount() adds up Payment::line_items.');

    $payment->setLineItem(new PaymentLineItem(array(
      'name' => 'beer',
      'amount' => 47.11,
    )));

    // Test Payment::totalAmount() with passed on amounts.
    $line_items = $payment->getLineItems('paymenttest');
    $this->assertTrue($payment->totalAmount(TRUE, $line_items) == 40.801, 'Payment::totalAmount() adds up only passed on line items.');

    // Test payment_line_item_get_specific() and whether
    // Payment::getLineItems() can get line items that are not exposed
    // through hook_payment_line_item_info().
    $line_items = $payment->getLineItems('beer');
    $this->assertTrue($payment->totalAmount(TRUE, $line_items) == 47.11, 'payment_line_item_get_specific() only returns the requested line item.');

    // Test payment_line_item_get_all().
    $line_items = $payment->getLineItems('payment_all');
    $this->assertTrue(count($line_items) == 3, 'payment_line_item_get_all() returns all line items.');
  }
}

/**
 * Test payment status item handling.
 */
class PaymentStatusItemTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment status item handling',
      'group' => 'Payment',
    );
  }

  /**
   * Implements DrupalWebTestCase::setUp().
   */
  function setUp() {
    parent::setUp('payment');
  }

  /**
   * Test payment status item handling.
   */
  function testPaymentStatusItem() {
    $payment = new Payment;
    $status_pending = new PaymentStatusItem(PAYMENT_STATUS_PENDING);
    $status_success = new PaymentStatusItem(PAYMENT_STATUS_SUCCESS);
    $payment->setStatus($status_pending);
    $payment->setStatus($status_success);
    $this->assertTrue($payment->getStatus() === $status_success, 'Payment::setStatus() sets status items in the right order and Payment::getStatus() retrieves them.');
  }
}

/**
 * Test payment validation.
 */
class PaymentValidationTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment validation',
      'group' => 'Payment',
    );
  }

  /**
   * Implements DrupalWebTestCase::setUp().
   */
  function setUp() {
    parent::setUp('payment', 'paymentmethodbasic', 'paymenttest');

    // Set up a valid payment.
    $this->payment_method = new PaymentMethod(array(
      'controller' => payment_method_controller_load('PaymentMethodBasicController'),
    ));
    $this->payment_method->controller->currencies = array(
      'XXX' => array(
        'minimum' => 10,
        'maximum' => 20,
      ),
    );
    $this->payment = new Payment(array(
      'currency_code' => 'XXX',
      'finish_callback' => 'paymenttest_finish_callback',
      'method' => $this->payment_method,
    ));
    $this->payment->setLineItem(new PaymentLineItem(array(
      'name' => 'paymenttest',
      'amount' => 15,
    )));
  }

  /**
   * Test payment validation.
   */
  function testPaymentValidation() {
    // Test that a valid payment validates.
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationException $e) {
      $valid = FALSE;
    }
    $this->assertTrue($valid, 'PaymentMethodController::validate() does not invalidate a valid payment.');

    // Test that a payment without a currency code set invalidates.
    $currency = $this->payment->currency_code;
    $this->payment->currency_code = '';
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationMissingCurrencyException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, 'PaymentMethodController::validate() invalidates a payment that has no currency set.');
    $this->payment->currency_code = $currency;

    // Test that a payment without a (callable) finish callback set
    // invalidates.
    $finish_callback = $this->payment->finish_callback;
    $this->payment->finish_callback = '';
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationMissingFinishCallback $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, 'PaymentMethodController::validate() invalidates a payment that has no (callable) finish callback set.');
    $this->payment->finish_callback = $finish_callback;

    // Test that a payment with a total amount below PAYMENT_MINIMUM_AMOUNT
    // invalidates.
    $currencies = $this->payment_method->controller->currencies;
    $this->payment_method->currencies = array();
    $line_items = $this->payment->line_items;
    $this->payment->line_items = array();
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountBelowMinimumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, 'PaymentMethodController::validate() invalidates a payment of which the amount is below the default minimum of ' . PAYMENT_MINIMUM_AMOUNT . '.');
    $this->payment_method->currencies = $currencies;
    $this->payment->line_items = $line_items;

    // Test that a payment with a total amount below its controller's minimum
    // invalidates.
    $line_items = $this->payment->line_items;
    $this->payment->line_items = array();
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountBelowMinimumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, "PaymentMethodController::validate() invalidates a payment of which the amount is below its controller's supported minimum.");
    $this->payment->line_items = $line_items;

    // Test that a payment with a total amount above its controller's maximum
    // invalidates.
    $this->payment->setLineItem(new PaymentLineItem(array(
      'name' => 'paymenttest2',
      'amount' => 25,
    )));
    try {
      $this->payment_method->validate($this->payment);
      $valid = TRUE;
    }
    catch (PaymentValidationAmountExceedsMaximumException $e) {
      $valid = FALSE;
    }
    $this->assertFalse($valid, "PaymentMethodController::validate() invalidates a payment of which the amount exceeds its controller's supported maximum.");
    unset($this->payment->line_items['paymenttest2']);
  }
}

/**
 * Tests the payment_line_item form element.
 */
class PaymentLineItemFormElementTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment line item form element',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'paymenttest');
    $this->PaymentLineItemData = array(
      'line_item[container_0][amount]' => '10.0',
      'line_item[container_0][description]' => 'foo',
      'line_item[container_0][name]' => 'bar',
      'line_item[container_0][quantity]' => '1',
      'line_item[container_0][tax_rate]' => '10',
    );
  }

  /**
   * Test the presence of widget's input elements.
   */
  function LineItemElements($delta_max = 0) {
    for ($delta = 0; $delta <= $delta_max; $delta++) {
      foreach (array('amount', 'description', 'name', 'quantity', 'tax-rate') as $name) {
        $elements = $this->xpath('//input[@id="edit-line-item-container-' . $delta . '-' . $name . '"]');
        $this->assertTrue(isset($elements[0]), "Payment line item configuration widget contains <em>$name</em> element for line item $delta.");
      }
    }
  }

  /**
   * Test the presence of widget's submit button.
   */
  function SubmitButton($present) {
    $elements = $this->xpath('//input[@id="payment-ajax-replace"]');
    if ($present) {
      $this->assertTrue(isset($elements[0]), "Payment line item configuration widget contains an <em>Add a line item</em> button if the number if line items is less than the widget's cardinality.");
    }
    else {
      $this->assertFalse(isset($elements[0]), 'Payment line item configuration widget contains no <em>Add a line item</em> button.');
    }
  }

  /**
   * Test a regular submission.
   */
  function testSubmission() {
    $this->drupalGet('paymenttest-form-element-payment-line-item');
    $this->LineItemElements();
    $this->SubmitButton(TRUE);
    $this->drupalPost(NULL, array(), t('Add a line item'));
    $this->LineItemElements(1);
    $this->SubmitButton(FALSE);
  }

  /**
   * Test an AJAX submission.
   */
  function testAJAXSubmission() {
    $this->drupalPostAJAX('paymenttest-form-element-payment-line-item', array(), 'payment-line-item', NULL, array(), array(), 'paymenttest-form-payment-line-item');
    $this->LineItemElements(1);
    $this->SubmitButton(FALSE);
  }

  /**
   * Test default value handling.
   */
  function testDefaultValues() {
    $this->drupalGet('paymenttest-form-element-payment-line-item/default-values');
    foreach (paymenttest_default_line_items() as $delta => $line_item) {
      $properties = array(
        'amount' => $line_item->amount,
        'description' => $line_item->description,
        'name' => $line_item->name,
        'quantity' => $line_item->quantity,
        'tax_rate' => $line_item->tax_rate * 100,
      );
      foreach ($properties as $property => $value) {
        $elements = $this->xpath('//input[@id="edit-line-item-container-' . $delta . '-' . drupal_clean_css_identifier($property) . '" and @value="' . $value . '"]');
        $this->assertTrue(isset($elements[0]), "The element contains the <em>$property</em> value for default line item $delta.");
      }
    }
  }

  /**
   * Test validation.
   */
  function testValidation() {
    // Test valid values.
    $this->drupalPost('paymenttest-form-element-payment-line-item', $this->PaymentLineItemData, t('Submit'));
    $this->assertUrl('user', array(), 'Valid values trigger form submission.');

    // Test leaving some elements empty.
    $values = array(
      'line_item[container_0][description]' => '',
    ) + $this->PaymentLineItemData;
    $this->drupalPost('paymenttest-form-element-payment-line-item', $values, t('Submit'));
    $this->assertRaw(t('%title is required, or leave all fields for this line item empty.', array(
      '%title' => t('Description'),
    )), "Partially filling in a line item's element throws a validation error.");

    // Test a non-integer quantity.
    $values =  array(
      'line_item[container_0][quantity]' => $this->randomName(2),
    );
    $this->drupalPost('paymenttest-form-element-payment-line-item', $values, t('Submit'));
    $this->assertText(t('Quantity should be a positive integer.'), 'A non-integer amount throws a validation error.');

    // Test a non-integer tax rate.
    $values =  array(
      'line_item[container_0][tax_rate]' => $this->randomName(2),
    );
    $this->drupalPost('paymenttest-form-element-payment-line-item', $values, t('Submit'));
    $this->assertText(t('Tax rate should be a positive integer.'), 'A non-integer tax rate throws a validation error.');
  }
}

/**
 * Tests the payment_line_item form element.
 */
class PaymentAmountFormElementTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment amount form element',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'paymenttest');
  }

  /**
   * Test validation.
   */
  function testValidation() {
    // Test valid values.
    $values =  array(
      'amount' => '49.95',
    );
    $this->drupalPost('paymenttest-form-element-payment-amount', $values, t('Submit'));
    $this->assertUrl('user', array(), 'A valid value higher than the default <em>#minimum_value</em> triggers form submission.');
    $values =  array(
      'amount' => '50,95',
    );
    $this->drupalPost('paymenttest-form-element-payment-amount/50', $values, t('Submit'));
    $this->assertUrl('user', array(), 'A valid value higher than an explicitely configured <em>#minimum_value</em> triggers form submission.');

    // Test illegal characters.
    $values =  array(
      'amount' => $this->randomName(2),
    );
    $this->drupalPost('paymenttest-form-element-payment-amount', $values, t('Submit'));
    $this->assertText(t('The amount can only consist of decimals and one decimal mark.'), 'Non-alphanumeric characters that are neither a period nor a comma throw a validation error.');

    // Test multiple decimal marks.
    $values =  array(
      'amount' => '49,.95',
    );
    $this->drupalPost('paymenttest-form-element-payment-amount', $values, t('Submit'));
    $this->assertText(t('The amount can only have one decimal mark.'), 'Multiple decimal marks throw a validation error.');

    // Test the minimum value.
    $values =  array(
      'amount' => '49.95',
    );
    $this->drupalPost('paymenttest-form-element-payment-amount/50', $values, t('Submit'));
    $this->assertText(t('The minimum amount is !amount.', array(
      '!amount' => payment_amount_human_readable(50, 'XXX'),
    )), 'An amount below the minimum throws a validation error.');
  }
}

/**
 * Tests payment method permissions.
 */
class PaymentMethodPermissionTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment method permissions',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'paymentmethodbasic');
  }

  function paymentMethod($uid = NULL) {
    return new PaymentMethod(array(
      'controller' => payment_method_controller_load('PaymentMethodBasicController'),
      'uid' => $uid,
    ));
  }

  /**
   * Test permissions.
   */
  function testPermissions() {
    $user_access_permissions = &drupal_static('user_access');
    $account_1 = drupal_anonymous_user();
    $account_1->uid = 1;
    $account_2 = drupal_anonymous_user();
    $account_2->uid = 2;

    // Create a new payment method.
    $this->paymentCheckEntityPermission($this->paymentMethod(), 'payment_method', array('payment.method.create.PaymentMethodBasicController'), 'create');

    // Update a payment method that belongs to user 1.
    $this->paymentCheckEntityPermission($this->paymentMethod(1), 'payment_method', array('payment.method.update.any'), 'update');

    // Update a payment method that belongs to user 2.
    $this->paymentCheckEntityPermission($this->paymentMethod(2), 'payment_method', array('payment.method.update.own'), 'update');

    // Delete a payment method that belongs to user 1.
    $this->paymentCheckEntityPermission($this->paymentMethod(1), 'payment_method', array('payment.method.delete.any'), 'delete');

    // Delete a payment method that belongs to user 2.
    $this->paymentCheckEntityPermission($this->paymentMethod(2), 'payment_method', array('payment.method.delete.own'), 'delete');

    // Enable an enabled payment method.
    $payment_method = $this->paymentMethod();
    $payment_method->enabled = TRUE;
    $this->assertFalse(payment_method_access('enable', $payment_method, $account_1), 'UID 1 cannot enable an enabled payment method');
    $permissions[2]['payment.method.update.any'] = TRUE;
    $this->assertFalse(payment_method_access('enable', $payment_method, $account_2), 'UID 2 cannot enable an enabled payment method ' . $this->paymentPermissionLabel(array('payment.method.update.any')));

    // Enable a disabled payment method that belongs to user 1.
    $payment_method = $this->paymentMethod(1);
    $payment_method->enabled = FALSE;
    $this->paymentCheckEntityPermission($payment_method, 'payment_method', array('payment.method.update.any'), 'enable');

    // Enable a disabled payment method that belongs to user 2.
    $payment_method = $this->paymentMethod(2);
    $payment_method->enabled = FALSE;
    $this->paymentCheckEntityPermission($payment_method, 'payment_method', array('payment.method.update.own'), 'enable');

    // Disable a disabled payment method.
    $payment_method = $this->paymentMethod();
    $payment_method->enabled = FALSE;
    $this->assertFalse(payment_method_access('disable', $payment_method, $account_1), 'UID 1 cannot disable a disabled payment method');
    $permissions[2]['payment.method.update.any'] = TRUE;
    $this->assertFalse(payment_method_access('disable', $payment_method, $account_2), 'UID 2 cannot disable a disabled payment method with permission ' . $this->paymentPermissionLabel(array('payment.method.update.any')));

    // Disable an enabled payment method that belongs to user 1.
    $this->paymentCheckEntityPermission($this->paymentMethod(1), 'payment_method', array('payment.method.update.any'), 'disable');

    // Disable an enabled payment method that belongs to user 2.
    $this->paymentCheckEntityPermission($this->paymentMethod(2), 'payment_method', array('payment.method.update.own'), 'disable');

    // Clone a payment method that belongs to user 1.
    $this->paymentCheckEntityPermission($this->paymentMethod(1), 'payment_method', array('payment.method.view.any', 'payment.method.create.PaymentMethodBasicController'), 'clone');

    // Clone a payment method that belongs to user 2.
    $this->paymentCheckEntityPermission($this->paymentMethod(2), 'payment_method', array('payment.method.view.own', 'payment.method.create.PaymentMethodBasicController'), 'clone');

    // View a payment method that belongs to user 1.
    $this->paymentCheckEntityPermission($this->paymentMethod(1), 'payment_method', array('payment.method.view.any'), 'view');

    // View a payment method that belongs to user 2.
    $this->paymentCheckEntityPermission($this->paymentMethod(2), 'payment_method', array('payment.method.view.own'), 'view');
  }
}

/**
 * Tests payment method permissions.
 */
class PaymentMethodAdministrationUIPermissionTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Payment method administration interface permissions',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment', 'paymentmethodbasic');
  }

  /**
   * Test permissions.
   */
  function testPermissions() {
    // Test the payment method overview.
    $this->paymentCheckPathPermission('admin/config/services/payment/method', 'payment.method.view.any', 'Views disabled');
    module_enable(array('views'));
    drupal_flush_all_caches();
    $this->paymentCheckPathPermission('admin/config/services/payment/method', 'payment.method.view.any', 'Views enabled');

    // Test the payment method controller selection page.
    $this->paymentCheckPathPermission('admin/config/services/payment/method/add', 'payment.method.create.PaymentMethodBasicController');

    // Test the payment method add page.
    $this->paymentCheckPathPermission('admin/config/services/payment/method/add/PaymentMethodBasicController', 'payment.method.create.PaymentMethodBasicController');

    $payment_method = $this->paymentMethodCreate();

    // Test the payment method edit page.
    $this->paymentCheckPathPermission('admin/config/services/payment/method/' . $payment_method->pmid . '/edit', 'payment.method.update.any');

    // Test the payment method delete page.
    $this->paymentCheckPathPermission('admin/config/services/payment/method/' . $payment_method->pmid . '/delete', 'payment.method.delete.any');
  }
}
/**
 * Test unavailable payment methods and payment methods controllers.
 */
class PaymentUnavailableTest extends PaymentWebTestCase {

  static function getInfo() {
    return array(
      'name' => 'Unavailable payment methods and payment method controllers',
      'group' => 'Payment',
    );
  }

  function setUp() {
    parent::setUp('payment');
  }

  /**
   * Test unavailable payment methods and payment method controllers.
   */
  function testUnavailable() {
    // Set a non-existing controller;
    $controller = new PaymentMethodController;
    $controller->name = 'foo';
    $payment = $this->paymentCreate($this->paymentMethodCreate($controller));
    $payment = entity_load_single('payment', $payment->pid);
    $this->assertEqual($payment->method->controller->name, 'PaymentMethodControllerUnavailable', 'When loading a payment method, if its controller unavailable, it is replaced by PaymentMethodControllerUnavailable.');
    entity_delete('payment_method', $payment->method->pmid);
    $payment = entity_load_single('payment', $payment->pid);
    $this->assertTrue(is_a($payment->method, 'PaymentMethodUnavailable'), 'When loading a payment, if its payment method is unavailable, it is replaced by PaymentMethodUnavailable.');
  }
}